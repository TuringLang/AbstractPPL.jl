var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#VarNames","page":"API","title":"VarNames","text":"","category":"section"},{"location":"api/#AbstractPPL.VarName","page":"API","title":"AbstractPPL.VarName","text":"VarName{sym}(optic=identity)\n\nA variable identifier for a symbol sym and optic optic.\n\nThe Julia variable in the model corresponding to sym can refer to a single value or to a hierarchical array structure of univariate, multivariate or matrix variables. The field lens stores the indices requires to access the random variable from the Julia variable indicated by sym as a tuple of tuples. Each element of the tuple thereby contains the indices of one optic operation.\n\nVarNames can be manually constructed using the VarName{sym}(optic) constructor, or from an optic expression through the @varname convenience macro.\n\nExamples\n\njulia> vn = VarName{:x}(Accessors.IndexLens((Colon(), 1)) â¨Ÿ Accessors.IndexLens((2, )))\nx[:, 1][2]\n\njulia> getoptic(vn)\n(@o _[Colon(), 1][2])\n\njulia> @varname x[:, 1][1+1]\nx[:, 1][2]\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractPPL.getsym","page":"API","title":"AbstractPPL.getsym","text":"getsym(vn::VarName)\n\nReturn the symbol of the Julia variable used to generate vn.\n\nExamples\n\njulia> getsym(@varname(x[1][2:3]))\n:x\n\njulia> getsym(@varname(y))\n:y\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.getoptic","page":"API","title":"AbstractPPL.getoptic","text":"getoptic(vn::VarName)\n\nReturn the optic of the Julia variable used to generate vn.\n\nExamples\n\njulia> getoptic(@varname(x[1][2:3]))\n(@o _[1][2:3])\n\njulia> getoptic(@varname(y))\nidentity (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.inspace","page":"API","title":"AbstractPPL.inspace","text":"inspace(vn::Union{VarName, Symbol}, space::Tuple)\n\nCheck whether vn's variable symbol is in space.  The empty tuple counts as the \"universal space\" containing all variables. Subsumption (see subsumes) is respected.\n\nExamples\n\njulia> inspace(@varname(x[1][2:3]), ())\ntrue\n\njulia> inspace(@varname(x[1][2:3]), (:x,))\ntrue\n\njulia> inspace(@varname(x[1][2:3]), (@varname(x),))\ntrue\n\njulia> inspace(@varname(x[1][2:3]), (@varname(x[1:10]), :y))\ntrue\n\njulia> inspace(@varname(x[1][2:3]), (@varname(x[:][2:4]), :y))\ntrue\n\njulia> inspace(@varname(x[1][2:3]), (@varname(x[1:10]),))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.subsumes","page":"API","title":"AbstractPPL.subsumes","text":"subsumes(u::VarName, v::VarName)\n\nCheck whether the variable name v describes a sub-range of the variable u.  Supported indexing:\n\nScalar:\n\n```jldoctest   julia> subsumes(@varname(x), @varname(x[1, 2]))   true\n\njulia> subsumes(@varname(x[1, 2]), @varname(x[1, 2][3]))   true   ```\n\nArray of scalar: basically everything that fulfills issubset.\n\n```jldoctest   julia> subsumes(@varname(x[[1, 2], 3]), @varname(x[1, 3]))   true\n\njulia> subsumes(@varname(x[1:3]), @varname(x[2][1]))   true   ```\n\nSlices:\n\njldoctest   julia> subsumes(@varname(x[2, :]), @varname(x[2, 10][1]))   true\n\nCurrently not supported are: \n\nBoolean indexing, literal CartesianIndex (these could be added, though)\nLinear indexing of multidimensional arrays: x[4] does not subsume x[2, 2] for a matrix x\nTrailing ones: x[2, 1] does not subsume x[2] for a vector x\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.subsumedby","page":"API","title":"AbstractPPL.subsumedby","text":"subsumedby(t, u)\n\nTrue if t is subsumed by u, i.e., if subsumes(u, t) is true.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.vsym","page":"API","title":"AbstractPPL.vsym","text":"vsym(expr)\n\nReturn name part of the @varname-compatible expression expr as a symbol for input of the VarName constructor.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.@varname","page":"API","title":"AbstractPPL.@varname","text":"@varname(expr, concretize=false)\n\nA macro that returns an instance of VarName given a symbol or indexing expression expr.\n\nIf concretize is true, the resulting expression will be wrapped in a concretize() call.\n\nNote that expressions involving dynamic indexing, i.e. begin and/or end, will always need to be concretized as VarName only supports non-dynamic indexing as determined by is_static_optic. See examples below.\n\nExamples\n\nDynamic indexing\n\njulia> x = (a = [1.0 2.0; 3.0 4.0; 5.0 6.0], );\n\njulia> @varname(x.a[1:end, end][:], true)\nx.a[1:3, 2][:]\n\njulia> @varname(x.a[end], false)  # disable concretization\nERROR: LoadError: Variable name `x.a[end]` is dynamic and requires concretization!\n[...]\n\njulia> @varname(x.a[end])  # concretization occurs by default if deemed necessary\nx.a[6]\n\njulia> # Note that \"dynamic\" here refers to usage of `begin` and/or `end`,\n       # _not_ \"information only available at runtime\", i.e. the following works.\n       [@varname(x.a[i]) for i = 1:length(x.a)][end]\nx.a[6]\n\njulia> # Potentially surprising behaviour, but this is equivalent to what Base does:\n       @varname(x[2:2:5]), 2:2:5\n(x[2:2:4], 2:2:4)\n\nGeneral indexing\n\nUnder the hood optics are used for the indexing:\n\njulia> getoptic(@varname(x))\nidentity (generic function with 1 method)\n\njulia> getoptic(@varname(x[1]))\n(@o _[1])\n\njulia> getoptic(@varname(x[:, 1]))\n(@o _[Colon(), 1])\n\njulia> getoptic(@varname(x[:, 1][2]))\n(@o _[Colon(), 1][2])\n\njulia> getoptic(@varname(x[1,2][1+5][45][3]))\n(@o _[1, 2][6][45][3])\n\nThis also means that we support property access:\n\njulia> getoptic(@varname(x.a))\n(@o _.a)\n\njulia> getoptic(@varname(x.a[1]))\n(@o _.a[1])\n\njulia> x = (a = [(b = rand(2), )], ); getoptic(@varname(x.a[1].b[end], true))\n(@o _.a[1].b[2])\n\nInterpolation can be used for variable names, or array name, but not the lhs of a . expression. Variables within indices are always evaluated in the calling scope.\n\njulia> name, i = :a, 10;\n\njulia> @varname(x.$name[i, i+1])\nx.a[10, 11]\n\njulia> @varname($name)\na\n\njulia> @varname($name[1])\na[1]\n\njulia> @varname($name.x[1])\na.x[1]\n\njulia> @varname(b.$name.x[1])\nb.a.x[1]\n\n\n\n\n\n","category":"macro"},{"location":"api/#AbstractPPL.@vsym","page":"API","title":"AbstractPPL.@vsym","text":"@vsym(expr)\n\nA macro that returns the variable symbol given the input variable expression expr. For example, @vsym x[1] returns :x.\n\nExamples\n\njulia> @vsym x\n:x\n\njulia> @vsym x[1,1][2,3]\n:x\n\njulia> @vsym x[end]\n:x\n\n\n\n\n\n","category":"macro"},{"location":"api/#VarName-prefixing-and-unprefixing","page":"API","title":"VarName prefixing and unprefixing","text":"","category":"section"},{"location":"api/#AbstractPPL.prefix","page":"API","title":"AbstractPPL.prefix","text":"prefix(vn::VarName, prefix::VarName)\n\nAdd a prefix to a VarName.\n\njulia> AbstractPPL.prefix(@varname(x), @varname(y))\ny.x\n\njulia> AbstractPPL.prefix(@varname(x.a), @varname(y))\ny.x.a\n\njulia> AbstractPPL.prefix(@varname(x.a), @varname(y[1]))\ny[1].x.a\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.unprefix","page":"API","title":"AbstractPPL.unprefix","text":"unprefix(vn::VarName, prefix::VarName)\n\nRemove a prefix from a VarName.\n\njulia> AbstractPPL.unprefix(@varname(y.x), @varname(y))\nx\n\njulia> AbstractPPL.unprefix(@varname(y.x.a), @varname(y))\nx.a\n\njulia> AbstractPPL.unprefix(@varname(y[1].x), @varname(y[1]))\nx\n\njulia> AbstractPPL.unprefix(@varname(y), @varname(n))\nERROR: ArgumentError: could not remove prefix n from VarName y\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#Extracting-values-corresponding-to-a-VarName","page":"API","title":"Extracting values corresponding to a VarName","text":"","category":"section"},{"location":"api/#AbstractPPL.hasvalue","page":"API","title":"AbstractPPL.hasvalue","text":"hasvalue(vals::NamedTuple, vn::VarName)\nhasvalue(vals::AbstractDict{<:VarName}, vn::VarName)\n\nDetermine whether vals contains a value for a given vn.\n\nExamples\n\nWith x as a NamedTuple:\n\njulia> hasvalue((x = 1.0, ), @varname(x))\ntrue\n\njulia> hasvalue((x = 1.0, ), @varname(x[1]))\nfalse\n\njulia> hasvalue((x = [1.0],), @varname(x))\ntrue\n\njulia> hasvalue((x = [1.0],), @varname(x[1]))\ntrue\n\njulia> hasvalue((x = [1.0],), @varname(x[2]))\nfalse\n\nWith x as a AbstractDict:\n\njulia> hasvalue(Dict(@varname(x) => 1.0, ), @varname(x))\ntrue\n\njulia> hasvalue(Dict(@varname(x) => 1.0, ), @varname(x[1]))\nfalse\n\njulia> hasvalue(Dict(@varname(x) => [1.0]), @varname(x))\ntrue\n\njulia> hasvalue(Dict(@varname(x) => [1.0]), @varname(x[1]))\ntrue\n\njulia> hasvalue(Dict(@varname(x) => [1.0]), @varname(x[2]))\nfalse\n\nIn the AbstractDict case we can also have keys such as v[1]:\n\njulia> vals = Dict(@varname(x[1]) => [1.0,]);\n\njulia> hasvalue(vals, @varname(x[1])) # same as `haskey`\ntrue\n\njulia> hasvalue(vals, @varname(x[1][1])) # different from `haskey`\ntrue\n\njulia> hasvalue(vals, @varname(x[1][2]))\nfalse\n\njulia> hasvalue(vals, @varname(x[2][1]))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.getvalue","page":"API","title":"AbstractPPL.getvalue","text":"getvalue(vals::AbstractDict, vn::VarName, dist::Distribution)\n\nRetrieve the value of vn from vals, using the distribution dist to reconstruct the value if necessary.\n\nThis is a more general version of getvalue(vals, vn), in that even if vn itself is not inside vals, it can still reconstruct the value of vn from sub-values of vn that are present in vals.\n\nFor example:\n\njulia> d = Dict(@varname(x[1]) => 1.0, @varname(x[2]) => 2.0);\n\njulia> getvalue(d, @varname(x), MvNormal(zeros(2), I))\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> # Use `hasvalue` to check for this case before calling `getvalue`.\n       getvalue(d, @varname(x), MvNormal(zeros(3), I))\nERROR: getvalue: `x` was not found in the values provided\n[...]\n\n\n\n\n\ngetvalue(vals::NamedTuple, vn::VarName)\ngetvalue(vals::AbstractDict{<:VarName}, vn::VarName)\n\nReturn the value(s) in vals represented by vn.\n\nExamples\n\nFor NamedTuple:\n\njulia> vals = (x = [1.0],);\n\njulia> getvalue(vals, @varname(x)) # same as `getindex`\n1-element Vector{Float64}:\n 1.0\n\njulia> getvalue(vals, @varname(x[1])) # different from `getindex`\n1.0\n\njulia> getvalue(vals, @varname(x[2]))\nERROR: getvalue: x[2] was not found in the values provided\n[...]\n\nFor AbstractDict:\n\njulia> vals = Dict(@varname(x) => [1.0]);\n\njulia> getvalue(vals, @varname(x)) # same as `getindex`\n1-element Vector{Float64}:\n 1.0\n\njulia> getvalue(vals, @varname(x[1])) # different from `getindex`\n1.0\n\njulia> getvalue(vals, @varname(x[2]))\nERROR: getvalue: x[2] was not found in the values provided\n[...]\n\nIn the AbstractDict case we can also have keys such as v[1]:\n\njulia> vals = Dict(@varname(x[1]) => [1.0,]);\n\njulia> getvalue(vals, @varname(x[1])) # same as `getindex`\n1-element Vector{Float64}:\n 1.0\n\njulia> getvalue(vals, @varname(x[1][1])) # different from `getindex`\n1.0\n\njulia> getvalue(vals, @varname(x[1][2]))\nERROR: getvalue: x[1][2] was not found in the values provided\n[...]\n\njulia> getvalue(vals, @varname(x[2][1]))\nERROR: getvalue: x[2][1] was not found in the values provided\n[...]\n\nDictionaries can present ambiguous cases where the same variable is specified twice at different levels. In such a situation, getvalue attempts to find an exact match, and if that fails it returns the value with the most specific key.\n\nnote: Note\nIt is the user's responsibility to avoid such cases by ensuring that the dictionary passed in does not contain the same value specified multiple times.\n\njulia> vals = Dict(@varname(x) => [[1.0]], @varname(x[1]) => [2.0]);\n\njulia> # Here, the `x[1]` key is not used because `x` is an exact match.\n       getvalue(vals, @varname(x))\n1-element Vector{Vector{Float64}}:\n [1.0]\n\njulia> # Likewise, the `x` key is not used because `x[1]` is an exact match.\n       getvalue(vals, @varname(x[1]))\n1-element Vector{Float64}:\n 2.0\n\njulia> # No exact match, so the most specific key, i.e. `x[1]`, is used.\n       getvalue(vals, @varname(x[1][1]))\n2.0\n\n\n\n\n\n","category":"function"},{"location":"api/#VarName-serialisation","page":"API","title":"VarName serialisation","text":"","category":"section"},{"location":"api/#AbstractPPL.index_to_dict","page":"API","title":"AbstractPPL.index_to_dict","text":"index_to_dict(::Integer)\nindex_to_dict(::AbstractVector{Int})\nindex_to_dict(::UnitRange)\nindex_to_dict(::StepRange)\nindex_to_dict(::Colon)\nindex_to_dict(::ConcretizedSlice{T, Base.OneTo{I}}) where {T, I}\nindex_to_dict(::Tuple)\n\nConvert an index i to a dictionary representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.dict_to_index","page":"API","title":"AbstractPPL.dict_to_index","text":"dict_to_index(dict)\ndict_to_index(symbol_val, dict)\n\nConvert a dictionary representation of an index dict to an index.\n\nUsers can extend the functionality of dict_to_index (and hence VarName de/serialisation) by extending this method along with index_to_dict. Specifically, suppose you have a custom index type MyIndexType and you want to be able to de/serialise a VarName containing this index type. You should then implement the following two methods:\n\nAbstractPPL.index_to_dict(i::MyModule.MyIndexType) should return a dictionary representation of the index i. This dictionary must contain the key \"type\", and the corresponding value must be a string that uniquely identifies the index type. Generally, it makes sense to use the name of the type (perhaps prefixed with module qualifiers) as this value to avoid clashes. The remainder of the dictionary can have any structure you like.\nSuppose the value of index_to_dict(i)[\"type\"] is \"MyModule.MyIndexType\". You should then implement the corresponding method AbstractPPL.dict_to_index(::Val{Symbol(\"MyModule.MyIndexType\")}, dict), which should take the dictionary representation as the second argument and return the original MyIndexType object.\n\nTo see an example of this in action, you can look in the the AbstractPPL test suite, which contains a test for serialising OffsetArrays.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.varname_to_string","page":"API","title":"AbstractPPL.varname_to_string","text":"varname_to_string(vn::VarName)\n\nConvert a VarName as a string, via an intermediate dictionary. This differs from string(vn) in that concretised slices are faithfully represented (rather than being pretty-printed as colons).\n\nFor VarNames which index into an array, this function will only work if the indices can be serialised. This is true for all standard Julia index types, but if you are using custom index types, you will need to implement the index_to_dict and dict_to_index methods for those types. See the documentation of dict_to_index for instructions on how to do this.\n\njulia> varname_to_string(@varname(x))\n\"{\\\"optic\\\":{\\\"type\\\":\\\"identity\\\"},\\\"sym\\\":\\\"x\\\"}\"\n\njulia> varname_to_string(@varname(x.a))\n\"{\\\"optic\\\":{\\\"field\\\":\\\"a\\\",\\\"type\\\":\\\"property\\\"},\\\"sym\\\":\\\"x\\\"}\"\n\njulia> y = ones(2); varname_to_string(@varname(y[:]))\n\"{\\\"optic\\\":{\\\"indices\\\":{\\\"values\\\":[{\\\"type\\\":\\\"Base.Colon\\\"}],\\\"type\\\":\\\"Base.Tuple\\\"},\\\"type\\\":\\\"index\\\"},\\\"sym\\\":\\\"y\\\"}\"\n\njulia> y = ones(2); varname_to_string(@varname(y[:], true))\n\"{\\\"optic\\\":{\\\"indices\\\":{\\\"values\\\":[{\\\"range\\\":{\\\"stop\\\":2,\\\"type\\\":\\\"Base.OneTo\\\"},\\\"type\\\":\\\"AbstractPPL.ConcretizedSlice\\\"}],\\\"type\\\":\\\"Base.Tuple\\\"},\\\"type\\\":\\\"index\\\"},\\\"sym\\\":\\\"y\\\"}\"\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.string_to_varname","page":"API","title":"AbstractPPL.string_to_varname","text":"string_to_varname(str::AbstractString)\n\nConvert a string representation of a VarName back to a VarName. The string should have been generated by varname_to_string.\n\n\n\n\n\n","category":"function"},{"location":"api/#Abstract-model-functions","page":"API","title":"Abstract model functions","text":"","category":"section"},{"location":"api/#AbstractPPL.AbstractProbabilisticProgram","page":"API","title":"AbstractPPL.AbstractProbabilisticProgram","text":"AbstractProbabilisticProgram\n\nCommon base type for models expressed as probabilistic programs.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractPPL.condition","page":"API","title":"AbstractPPL.condition","text":"condition(model, observations)\n\nCondition the generative model model on some observed data, creating a new model of the (possibly unnormalized) posterior distribution over them.\n\nobservations can be of any supported internal trace type, or a fixed probability expression.\n\nThe invariant \n\nm = decondition(condition(m, obs))\n\nshould hold for generative models m and arbitrary obs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.decondition","page":"API","title":"AbstractPPL.decondition","text":"decondition(conditioned_model)\n\nRemove the conditioning (i.e., observation data) from conditioned_model, turning it into a generative model over prior and observed variables.\n\nThe invariant \n\nm == condition(decondition(m), obs)\n\nshould hold for models m with conditioned variables obs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.fix","page":"API","title":"AbstractPPL.fix","text":"fix(model, params)\n\nFix the values of parameters specified in params within the probabilistic model model.  This operation is equivalent to treating the fixed parameters as being drawn from a point mass  distribution centered at the values specified in params. Thus these parameters no longer contribute to the accumulated log density. \n\nConceptually, this is similar to Pearl's do-operator in causal inference, where we intervene  on variables by setting them to specific values, effectively cutting off their dependencies  on their usual causes in the model.\n\nThe invariant\n\nm == unfix(fix(m, params))\n\nshould hold for any model m and parameters params.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.unfix","page":"API","title":"AbstractPPL.unfix","text":"unfix(model)\n\nRemove any fixed parameters from the model model, returning a new model without the fixed parameters.\n\nThis function reverses the effect of fix by removing parameter constraints that were previously set. It returns a new model where all previously fixed parameters are allowed to vary according to their  original distributions in the model.\n\nThe invariant\n\nm == unfix(fix(m, params))\n\nshould hold for any model m and parameters params.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityInterface.logdensityof","page":"API","title":"DensityInterface.logdensityof","text":"logdensityof(model, trace)\n\nEvaluate the (possibly unnormalized) density of the model specified by the probabilistic program in model, at specific values for the random variables given through trace.\n\ntrace can be of any supported internal trace type, or a fixed probability expression.\n\nlogdensityof should interact with conditioning and deconditioning in the way required by probability theory.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractPPL.AbstractContext","page":"API","title":"AbstractPPL.AbstractContext","text":"AbstractContext\n\nCommon base type for evaluation contexts.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractPPL.evaluate!!","page":"API","title":"AbstractPPL.evaluate!!","text":"evaluate!!\n\nGeneral API for model operations, e.g. prior evaluation, log density, log joint etc.\n\n\n\n\n\n","category":"function"},{"location":"api/#Abstract-traces","page":"API","title":"Abstract traces","text":"","category":"section"},{"location":"api/#AbstractPPL.AbstractModelTrace","page":"API","title":"AbstractPPL.AbstractModelTrace","text":"AbstractModelTrace\n\nCommon base class for various trace or \"variable info\" types.\n\n\n\n\n\n","category":"type"},{"location":"#AbstractPPL.jl","page":"Home","title":"AbstractPPL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lightweight package containing interfaces and associated APIs for modelling languages for probabilistic programming.","category":"page"}]
}
