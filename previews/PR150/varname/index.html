<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>VarNames and optics · AbstractPPL</title><meta name="title" content="VarNames and optics · AbstractPPL"/><meta property="og:title" content="VarNames and optics · AbstractPPL"/><meta property="twitter:title" content="VarNames and optics · AbstractPPL"/><meta name="description" content="Documentation for AbstractPPL."/><meta property="og:description" content="Documentation for AbstractPPL."/><meta property="twitter:description" content="Documentation for AbstractPPL."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body>
<!-- NAVBAR START -->
<style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap');

    /* Documenter.jl CSS Overrides */
    html {
        scroll-padding-top: calc(var(--navbar-height) + 1rem);
    }
    .docs-sidebar, #documenter {
        margin-top: var(--navbar-height);
    }
    .docs-version-selector {
        margin-bottom: 60px !important;
    }
    @media screen and (max-width: 1056px) {
        .docs-version-selector {
            margin-bottom: 60px !important;
        }
        .docs-sidebar {
            margin-top: 0 !important;
        }
    }
    /* End of Documenter.jl Tweaks */

    /* Color and Font Variables */
    :root {
        --heading-color: #6c757d;
        --item-color: rgb(165, 165, 165);
        --primary-bg: white;
        --hover-color: #8faad2;
        --deprecated-bg: #ff4d4d;
        --deprecated-text: white;
        --icon-color: #6c757d;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e9ecef;
        
        /* Typography */
        --font-family: "Source Sans Pro", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        --nav-link-font-size: 1.0625rem;
        --turing-title-font-size: 21.25px;
        --icon-font-size: 1.25rem;
        --dropdown-arrow-font-size: 0.6875rem;
        --badge-font-size: 0.75rem;

        /* Sizing and Spacing */
        --navbar-height: 3.75rem;
        --logo-height: 31px;
        --logo-width: auto;
        --logo-padding-top: 7px;
        --logo-margin-left: 0.8rem;
        --title-margin-left: 0.4px;
        --title-nav-spacing: 1.1rem;
        --nav-item-margin-left: 1.3rem;
        --icon-margin-left: 1rem;
        --dropdown-padding: 1.875rem;
        --dropdown-item-width: 12.5rem;
        --dropdown-subitem-width: 15.625rem;
        --dropdown-subitem-padding: 0.125rem 0.625rem;
    }

    /* Dark Theme Variable Overrides */
    html.theme--documenter-dark {
        --heading-color: #e0e0e0;
        --item-color: #bdbdbd;
        --primary-bg: #1f2424;
        --hover-color: #ffffff;
        --icon-color: #e0e0e0;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #424242;
    }

    /* Catppuccin Theme Overrides */
    html.theme--catppuccin-latte {
        --heading-color: #4c4f69;
        --primary-bg: #eff1f5;
        --icon-color: #4c4f69;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e6e9ef;
    }
    html.theme--catppuccin-frappe {
        --heading-color: #c6d0f5;
        --primary-bg: #303446;
        --icon-color: #c6d0f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #51576d;
    }
    html.theme--catppuccin-macchiato {
        --heading-color: #cad3f5;
        --primary-bg: #24273a;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #494d64;
    }
    html.theme--catppuccin-mocha {
        --heading-color: #cad3f5;
        --primary-bg: #1e1e2e;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #45475a;
    }


    /* Main Navigation Bar */
    .ext-navigation {
        font-family: var(--font-family);
        position: fixed;
        height: var(--navbar-height);
        top: 0;
        width: 100%;
        background-color: var(--primary-bg);
        z-index: 1000;
        box-shadow: 0 2px 4px var(--shadow-color);
        display: flex;
        align-items: center;
        padding: 0 1.0625rem;
        transition: transform 0.3s, background-color 0.3s;
    }

    nav.ext-navigation .ext-navbar-logo {
        margin-left: var(--logo-margin-left);
        height: auto;
        max-height: var(--logo-height);
        width: auto;
        padding-top: var(--logo-padding-top);
    }
    
    /* Theme-aware logo text color */
    .ext-navbar-logo .logo-text {
        fill: var(--heading-color);
    }
    
    .ext-navbar-title {
        color: var(--heading-color) !important;
        font-size: var(--turing-title-font-size) !important;
        margin-left: var(--title-margin-left);
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .ext-navbar-title:hover {
        color: var(--hover-color) !important;
    }

    .ext-nav-links {
        display: flex;
        align-items: center;
        list-style-type: none;
        margin: 0;
        padding: 0;
        flex-grow: 1;
        margin-left: var(--title-nav-spacing);
    }

    .ext-nav-links li:first-child {
        margin-left: 0 !important;
    }

    .ext-nav-links li {
        margin-left: var(--nav-item-margin-left) !important;
    }

    .ext-nav-link {
        color: var(--heading-color) !important;
        text-decoration: none;
        font-size: var(--nav-link-font-size) !important;
        transition: color 0.2s ease;
        cursor: pointer;
    }

    .ext-nav-link:hover,
    .ext-navbar-item-single a:hover,
    .ext-navbar-icons a:hover {
        color: var(--hover-color) !important;
    }

    .ext-navbar-item-single a {
        color: var(--heading-color) !important;
    }
    
    .ext-navbar-icons {
        display: flex;
        align-items: center;
    }

    .ext-navbar-icons a {
        color: var(--icon-color) !important;
        font-size: var(--icon-font-size) !important;
        transition: color 0.2s ease;
        margin-left: var(--icon-margin-left);
    }

    .ext-menu-toggle {
        display: none;
        font-size: 1.5rem;
        color: var(--heading-color);
        cursor: pointer;
    }

    .ext-dropdown {
        display: none;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        padding: var(--dropdown-padding);
        position: absolute;
        top: var(--navbar-height);
        width: 100%;
        left: 0;
        background-color: var(--primary-bg);
        line-height: 1.875rem;
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, background-color 0.3s;
        transform: translateY(-0.625rem);
        box-shadow: 0 4px 6px var(--shadow-color);
    }

    #library-handler::after {
        content: "▼";
        font-size: var(--dropdown-arrow-font-size);
        margin-left: 0.3125rem;
        transition: transform 0.3s ease-in-out;
    }

    #library-handler.open::after {
        content: "▲";
    }

    .ext-dropdown.show {
        display: grid;
        opacity: 1;
        transform: translateY(0);
    }

    .ext-dropdown ul {
        width: var(--dropdown-item-width);
        margin-bottom: 1.25rem;
    }

    .ext-dropdown ul li {
        text-align: left;
        display: flex;
        align-items: center;
    }

    .ext-dropdown ul a li {
        color: var(--item-color);
        width: var(--dropdown-subitem-width);
        border-radius: 3px;
        padding: var(--dropdown-subitem-padding);
        transition: background-color 0.2s ease;
    }

    .ext-dropdown ul a li:hover {
        background-color: var(--dropdown-hover-bg);
    }

    .ext-dropdown-item-heading {
        color: var(--heading-color);
        text-align: center;
    }

    .deprecated-badge {
        background-color: var(--deprecated-bg);
        color: var(--deprecated-text);
        font-size: var(--badge-font-size);
        padding: .1rem;
        border-radius: 3px;
        margin-left: 0.5rem;
        line-height: 1;
    }

    @media (max-width: 966px) {
        .ext-dropdown {
            grid-template-columns: 1fr 1fr 1fr;
        }
    }

    @media (max-width: 768px) {
        .ext-nav-links {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: var(--primary-bg);
            position: absolute;
            top: var(--navbar-height);
            left: 0;
            padding: 0.625rem 0;
            height: auto;
            overflow-y: auto;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-left: 0;
        }

        .ext-nav-links.show {
            display: flex;
        }

        .ext-nav-links li {
            margin: 0.625rem 0 !important;
            text-align: center;
        }
        
        .ext-menu-toggle {
            display: block;
            margin-left: auto;
        }

        .ext-navigation.hide {
            transform: translateY(calc(-1 * var(--navbar-height)));
        }

        .ext-dropdown {
            position: static;
            display: block;
            opacity: 1;
            transform: none;
            box-shadow: none;
            grid-template-columns: 1fr;
            padding: 0.625rem;
            text-align: center;
        }

        .ext-dropdown ul {
            width: auto;
            display: inline-block;
            margin: 0 auto 0.3125rem;
            text-align: left;
        }
    }
</style>
<nav class="ext-navigation">
    <a href="https://turinglang.org/">
        <svg width="4333" height="1145" viewBox="0 0 4333 1145" fill="none" xmlns="http://www.w3.org/2000/svg" class="ext-navbar-logo">
            <path class="logo-text" d="M0.44603 193.181V66.9868H663.471V193.181H406.62V898H257.297V193.181H0.44603ZM1097.24 635.874V274.74H1244.13V898H1101.7V787.225H1095.21C1081.14 822.121 1058.01 850.66 1025.82 872.842C993.902 895.024 954.542 906.115 907.744 906.115C866.896 906.115 830.783 897.053 799.403 878.929C768.295 860.534 743.948 833.889 726.365 798.993C708.782 763.826 699.99 721.356 699.99 671.581V274.74H846.878V648.858C846.878 688.353 857.699 719.733 879.34 742.997C900.981 766.261 929.385 777.893 964.551 777.893C986.192 777.893 1007.16 772.618 1027.45 762.068C1047.73 751.518 1064.37 735.828 1077.35 714.999C1090.61 693.899 1097.24 667.524 1097.24 635.874ZM1395.17 898V274.74H1537.6V378.617H1544.09C1555.45 342.639 1574.93 314.911 1602.52 295.434C1630.38 275.687 1662.17 265.813 1697.88 265.813C1705.99 265.813 1715.05 266.219 1725.06 267.031C1735.34 267.572 1743.86 268.518 1750.63 269.871V404.992C1744.4 402.828 1734.53 400.934 1721 399.311C1707.75 397.417 1694.9 396.471 1682.46 396.471C1655.68 396.471 1631.6 402.287 1610.23 413.919C1589.13 425.28 1572.49 441.105 1560.32 461.393C1548.15 481.682 1542.06 505.081 1542.06 531.591V898H1395.17ZM1848.21 898V274.74H1995.1V898H1848.21ZM1922.06 186.283C1898.8 186.283 1878.78 178.573 1862.01 163.154C1845.24 147.464 1836.85 128.664 1836.85 106.752C1836.85 84.5701 1845.24 65.7695 1862.01 50.3503C1878.78 34.6606 1898.8 26.8158 1922.06 26.8158C1945.6 26.8158 1965.61 34.6606 1982.12 50.3503C1998.89 65.7695 2007.27 84.5701 2007.27 106.752C2007.27 128.664 1998.89 147.464 1982.12 163.154C1965.61 178.573 1945.6 186.283 1922.06 186.283ZM2293.04 532.809V898H2146.15V274.74H2286.54V380.646H2293.85C2308.18 345.75 2331.04 318.022 2362.42 297.463C2394.07 276.904 2433.16 266.625 2479.69 266.625C2522.7 266.625 2560.17 275.822 2592.09 294.217C2624.28 312.612 2649.17 339.257 2666.75 374.153C2684.6 409.049 2693.39 451.385 2693.12 501.159V898H2546.24V523.882C2546.24 482.223 2535.41 449.626 2513.77 426.092C2492.4 402.557 2462.78 390.79 2424.91 390.79C2399.21 390.79 2376.35 396.471 2356.34 407.832C2336.59 418.923 2321.03 435.019 2309.67 456.119C2298.58 477.218 2293.04 502.782 2293.04 532.809ZM3113.5 1144.71C3060.75 1144.71 3015.44 1137.54 2977.57 1123.2C2939.7 1109.13 2909.26 1090.2 2886.27 1066.39C2863.28 1042.59 2847.32 1016.21 2838.39 987.269L2970.67 955.213C2976.62 967.386 2985.28 979.424 2996.64 991.327C3008 1003.5 3023.28 1013.51 3042.49 1021.35C3061.97 1029.47 3086.45 1033.53 3115.93 1033.53C3157.59 1033.53 3192.08 1023.38 3219.4 1003.09C3246.73 983.076 3260.39 950.074 3260.39 904.087V786.008H3253.08C3245.51 801.157 3234.42 816.711 3219.81 832.671C3205.47 848.632 3186.4 862.022 3162.6 872.842C3139.06 883.663 3109.44 889.073 3073.73 889.073C3025.85 889.073 2982.44 877.847 2943.48 855.394C2904.8 832.671 2873.96 798.857 2850.97 753.952C2828.24 708.777 2816.88 652.24 2816.88 584.341C2816.88 515.902 2828.24 458.147 2850.97 411.078C2873.96 363.739 2904.93 327.896 2943.89 303.55C2982.84 278.933 3026.26 266.625 3074.14 266.625C3110.66 266.625 3140.69 272.847 3164.22 285.29C3188.03 297.463 3206.96 312.206 3221.03 329.519C3235.09 346.561 3245.78 362.657 3253.08 377.805H3261.2V274.74H3406.06V908.144C3406.06 961.435 3393.34 1005.53 3367.92 1040.42C3342.49 1075.32 3307.73 1101.43 3263.63 1118.74C3219.54 1136.05 3169.5 1144.71 3113.5 1144.71ZM3114.72 773.835C3145.83 773.835 3172.34 766.261 3194.25 751.112C3216.16 735.963 3232.79 714.187 3244.16 685.783C3255.52 657.379 3261.2 623.295 3261.2 583.53C3261.2 544.305 3255.52 509.95 3244.16 480.465C3233.07 450.979 3216.56 428.12 3194.65 411.89C3173.01 395.389 3146.37 387.138 3114.72 387.138C3081.98 387.138 3054.66 395.659 3032.75 412.701C3010.84 429.744 2994.34 453.143 2983.25 482.899C2972.16 512.385 2966.61 545.929 2966.61 583.53C2966.61 621.672 2972.16 655.08 2983.25 683.754C2994.61 712.158 3011.25 734.34 3033.16 750.3C3055.34 765.99 3082.53 773.835 3114.72 773.835ZM3647.08 906.927C3622.47 906.927 3601.37 898.271 3583.78 880.958C3566.2 863.645 3557.54 842.545 3557.82 817.658C3557.54 793.312 3566.2 772.482 3583.78 755.17C3601.37 737.857 3622.47 729.2 3647.08 729.2C3670.89 729.2 3691.58 737.857 3709.17 755.17C3727.02 772.482 3736.08 793.312 3736.35 817.658C3736.08 834.159 3731.75 849.173 3723.37 862.698C3715.25 876.224 3704.43 887.044 3690.91 895.16C3677.65 903.004 3663.04 906.927 3647.08 906.927ZM3888.01 274.74H4034.9V933.708C4034.9 978.613 4026.38 1015.67 4009.33 1044.89C3992.29 1074.1 3967.67 1095.88 3935.48 1110.22C3903.29 1124.55 3864.2 1131.72 3818.22 1131.72C3812.81 1131.72 3807.8 1131.59 3803.2 1131.32C3798.6 1131.32 3793.6 1131.18 3788.19 1130.91V1011.21C3792.25 1011.48 3795.9 1011.62 3799.15 1011.62C3802.39 1011.89 3805.77 1012.02 3809.29 1012.02C3837.42 1012.02 3857.58 1005.12 3869.75 991.327C3881.92 977.801 3888.01 957.918 3888.01 931.679V274.74ZM3961.05 186.283C3937.51 186.283 3917.36 178.573 3900.59 163.154C3884.09 147.464 3875.84 128.664 3875.84 106.752C3875.84 84.5701 3884.09 65.7695 3900.59 50.3503C3917.36 34.6606 3937.51 26.8158 3961.05 26.8158C3984.31 26.8158 4004.19 34.6606 4020.7 50.3503C4037.47 65.7695 4045.85 84.5701 4045.85 106.752C4045.85 128.664 4037.47 147.464 4020.7 163.154C4004.19 178.573 3984.31 186.283 3961.05 186.283ZM4332.83 66.9868V898H4185.94V66.9868H4332.83Z" fill="currentColor"/>
            <path d="M4076 108.5C4076 168.424 4027.42 217 3967.5 217C3907.58 217 3859 168.424 3859 108.5C3859 48.5762 3907.58 0 3967.5 0C4027.42 0 4076 48.5762 4076 108.5Z" fill="#389725"/>
            <path d="M3755 814.5C3755 874.424 3706.42 923 3646.5 923C3586.58 923 3538 874.424 3538 814.5C3538 754.576 3586.58 706 3646.5 706C3706.42 706 3755 754.576 3755 814.5Z" fill="#9457B1"/>
            <path d="M2030 108.5C2030 168.424 1981.42 217 1921.5 217C1861.58 217 1813 168.424 1813 108.5C1813 48.5762 1861.58 0 1921.5 0C1981.42 0 2030 48.5762 2030 108.5Z" fill="#CA3B33"/>
        </svg>
    </a>
    <!-- <a class="ext-navbar-title" href="https://turinglang.org/">Turing.jl</a> -->
    
    <ul class="ext-nav-links">
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/getting-started/">Get Started</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/tutorials/">Tutorials</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/faq/">FAQ</a></li>
        <li>
            <p class="ext-nav-link" id="library-handler">Libraries</p>
            <div class="ext-dropdown" id="ext-dropdown-items">
                <ul>
                    <li class="ext-dropdown-item-heading">Modelling Languages</li>
                    <a href="https://turinglang.org/DynamicPPL.jl/"><li>DynamicPPL</li></a>
                    <a href="https://turinglang.org/JuliaBUGS.jl/"><li>JuliaBUGS</li></a>
                    <a href="https://turinglang.org/TuringGLM.jl/"><li>TuringGLM</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">MCMC</li>
                    <a href="https://turinglang.org/AdvancedHMC.jl/"><li>AdvancedHMC</li></a>
                    <a href="https://turinglang.org/AbstractMCMC.jl/"><li>AbstractMCMC</li></a>
                    <a href="https://github.com/theogf/ThermodynamicIntegration.jl"><li>ThermodynamicIntegration</li></a>
                    <a href="https://turinglang.org/AdvancedPS.jl/"><li>AdvancedPS</li></a>
                    <a href="https://turinglang.org/SliceSampling.jl/"><li>SliceSampling</li></a>
                    <a href="https://turinglang.org/EllipticalSliceSampling.jl/"><li>EllipticalSliceSampling</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Diagnostics</li>
                    <a href="https://turinglang.org/MCMCChains.jl/"><li>MCMCChains</li></a>
                    <a href="https://turinglang.org/MCMCDiagnosticTools.jl/"><li>MCMCDiagnosticTools</li></a>
                    <a href="https://turinglang.org/ParetoSmooth.jl/"><li>ParetoSmooth</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Gaussian Processes</li>
                    <a href="https://juliagaussianprocesses.github.io/AbstractGPs.jl/"><li>AbstractGPs</li></a>
                    <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/"><li>KernelFunctions</li></a>
                    <a href="https://juliagaussianprocesses.github.io/ApproximateGPs.jl/"><li>ApproximateGPs</li></a>
                </ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Bijectors.jl/">Bijectors</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/TuringCallbacks.jl/">TuringCallbacks</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Deprecated/TuringBenchmarking/">TuringBenchmarking</a><span class="deprecated-badge">Deprecated</span></li></ul>
            </div>
        </li>
        <li><a class="ext-nav-link" href="https://turinglang.org/news/">News</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/team/">Team</a></li>
    </ul>

    <div class="ext-navbar-icons">
        <a href="https://x.com/TuringLang" aria-label="Turing on X"><i class="fa-brands fa-x-twitter"></i></a>
        <a href="https://discourse.julialang.org/c/domain/probprog/48" aria-label="Turing on Discourse"><i class="fa-brands fa-discourse"></i></a>
        <a href="https://julialang.slack.com/archives/CCYDC34A0" aria-label="Turing on Slack"><i class="fa-brands fa-slack"></i></a>
        <a href="https://github.com/TuringLang/" aria-label="Turing.jl on GitHub"><i class="fa-brands fa-github"></i></a>
    </div>

    <span class="ext-menu-toggle"><i class="fa-solid fa-bars"></i></span>
</nav>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const menuToggle = document.querySelector(".ext-menu-toggle");
        const navLinks = document.querySelector(".ext-nav-links");
        const nav = document.querySelector(".ext-navigation");
        const libraryHandler = document.getElementById("library-handler");
        const dropdownContainer = document.getElementById("ext-dropdown-items");
        let lastScrollY = window.scrollY;

        function closeDropdown() {
            if (dropdownContainer.classList.contains("show")) {
                libraryHandler.classList.remove("open");
                dropdownContainer.classList.remove("show");
                setTimeout(() => {
                    if (!dropdownContainer.classList.contains("show")) {
                        dropdownContainer.style.display = "none";
                    }
                }, 300);
            }
        }

        function openDropdown() {
            dropdownContainer.style.display = "grid";
            libraryHandler.classList.add("open");
            setTimeout(() => {
                dropdownContainer.classList.add("show");
            }, 10);
        }

        function setAppropriateHeight() {
            if (window.innerWidth <= 768) {
                const viewportHeight = window.innerHeight;
                const navHeight = nav.offsetHeight;
                navLinks.style.maxHeight = `${viewportHeight - navHeight}px`;
                navLinks.style.overflowY = "auto";
            } else {
                navLinks.style.maxHeight = "";
                navLinks.style.overflowY = "";
            }
        }

        menuToggle.addEventListener("click", (event) => {
            event.stopPropagation();
            navLinks.classList.toggle("show");
            if (navLinks.classList.contains("show")) {
                setAppropriateHeight();
                closeDropdown();
                dropdownContainer.style.display = "none";
            }
        });

        libraryHandler.addEventListener("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
            if (dropdownContainer.classList.contains("show")) {
                closeDropdown();
            } else {
                openDropdown();
            }
            setAppropriateHeight();
        });

        // Close all menus if a click is registered outside the navigation bar.
        document.addEventListener("click", (event) => {
            if (!nav.contains(event.target)) {
                navLinks.classList.remove("show");
                closeDropdown();
            }
        });

        // Hide navigation bar on scroll down in mobile view.
        window.addEventListener("scroll", () => {
            if (window.innerWidth <= 768) {
                if (window.scrollY > lastScrollY && window.scrollY > nav.offsetHeight){
                    nav.classList.add("hide");
                } else {
                    nav.classList.remove("hide");
                }
                lastScrollY = window.scrollY;
            }
        });

        window.addEventListener("resize", setAppropriateHeight);
    });
</script>
<!-- NAVBAR END -->


<div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractPPL</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractPPL.jl</a></li><li class="is-active"><a class="tocitem" href>VarNames and optics</a><ul class="internal"><li><a class="tocitem" href="#VarNames:-an-overview"><span>VarNames: an overview</span></a></li><li><a class="tocitem" href="#Dynamic-indices"><span>Dynamic indices</span></a></li><li><a class="tocitem" href="#Optics"><span>Optics</span></a></li><li><a class="tocitem" href="#Getting-and-setting"><span>Getting and setting</span></a></li><li><a class="tocitem" href="#Composing-and-decomposing-optics"><span>Composing and decomposing optics</span></a></li><li><a class="tocitem" href="#Converting-VarNames-to-optics-and-back"><span>Converting VarNames to optics and back</span></a></li><li><a class="tocitem" href="#Subsumption"><span>Subsumption</span></a></li><li><a class="tocitem" href="#Prefixing-and-unprefixing"><span>Prefixing and unprefixing</span></a></li><li><a class="tocitem" href="#VarName-leaves"><span>VarName leaves</span></a></li><li><a class="tocitem" href="#Reading-from-a-container-with-a-VarName-(or-optic)"><span>Reading from a container with a VarName (or optic)</span></a></li><li><a class="tocitem" href="#Serializing-VarNames"><span>Serializing VarNames</span></a></li></ul></li><li><a class="tocitem" href="../pplapi/">Probabilistic programming API</a></li><li><a class="tocitem" href="../interface/">Interface (outdated)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>VarNames and optics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>VarNames and optics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TuringLang/AbstractPPL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TuringLang/AbstractPPL.jl/blob/main/docs/src/varname.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="VarNames-and-optics"><a class="docs-heading-anchor" href="#VarNames-and-optics">VarNames and optics</a><a id="VarNames-and-optics-1"></a><a class="docs-heading-anchor-permalink" href="#VarNames-and-optics" title="Permalink"></a></h1><h2 id="VarNames:-an-overview"><a class="docs-heading-anchor" href="#VarNames:-an-overview">VarNames: an overview</a><a id="VarNames:-an-overview-1"></a><a class="docs-heading-anchor-permalink" href="#VarNames:-an-overview" title="Permalink"></a></h2><p>One of the most important parts of AbstractPPL.jl is the <code>VarName</code> type, which is used throughout the TuringLang ecosystem to represent names of random variables.</p><p>Fundamentally, a <code>VarName</code> comprises a symbol (which represents the name of the variable itself) and an optic (which tells us which part of the variable we might be interested in). For example, <code>x.a[1]</code> means the first element of the field <code>a</code> of the variable <code>x</code>. Here, <code>x</code> is the symbol, and <code>.a[1]</code> is the optic.</p><p>VarNames can be created using the <code>@varname</code> macro:</p><pre><code class="language-julia hljs">using AbstractPPL

vn = @varname(x.a[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x.a[1]</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.VarName"><a class="docstring-binding" href="#AbstractPPL.VarName"><code>AbstractPPL.VarName</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VarName{sym}(optic=identity)</code></pre><p>A variable identifier for a symbol <code>sym</code> and optic <code>optic</code>. <code>sym</code> refers to the name of the  top-level Julia variable, while <code>optic</code> allows one to specify a particular property or index inside that variable.</p><p><code>VarName</code>s can be manually constructed using the <code>VarName{sym}(optic)</code> constructor, or from an optic expression through the <a href="#AbstractPPL.@varname"><code>@varname</code></a> convenience macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.@varname"><a class="docstring-binding" href="#AbstractPPL.@varname"><code>AbstractPPL.@varname</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@varname(expr, concretize=false)</code></pre><p>Create a <a href="#AbstractPPL.VarName"><code>VarName</code></a> given an expression <code>expr</code> representing a variable or part of it.</p><p><strong>Basic examples</strong></p><p>In general, <code>VarName</code>s must have a top-level symbol representing the identifier itself, and can then have any number of property accesses or indexing operations chained to it.</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(x)
x

julia&gt; @varname(x.a.b.c)
x.a.b.c

julia&gt; @varname(x[1][2][3])
x[1][2][3]

julia&gt; @varname(x.a[1:3].b[2])
x.a[1:3].b[2]</code></pre><p><strong>Dynamic indices</strong></p><p>Some expressions may involve dynamic indices, specifically, <code>begin</code>, <code>end</code>. These indices cannot be resolved, or &#39;concretized&#39;, until the value being indexed into is known. By default, <code>@varname(...)</code> will not automatically concretize these expressions, and thus the resulting <code>VarName</code> will contain markers for these.</p><p>Note that colons are not considered dynamic.</p><pre><code class="language-julia-repl hljs">julia&gt; vn = @varname(x[end])
x[DynamicIndex(end)]

julia&gt; vn = @varname(x[1, end-1])
x[1, DynamicIndex(end - 1)]</code></pre><p>You can detect whether a <code>VarName</code> contains any dynamic indices using <a href="#AbstractPPL.is_dynamic"><code>is_dynamic</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; vn = @varname(x[1, end-1]); AbstractPPL.is_dynamic(vn)
true</code></pre><p>To concretize such expressions, you can call <a href="#AbstractPPL.concretize"><code>concretize</code></a> on the resulting <code>VarName</code>. After concretization, the resulting <code>VarName</code> will no longer be dynamic.</p><pre><code class="language-julia-repl hljs">julia&gt; x = randn(2, 3);

julia&gt; vn = @varname(x[1, end-1]); vn2 = AbstractPPL.concretize(vn, x)
x[1, 2]

julia&gt; getoptic(vn2).ix  # Just an ordinary tuple.
(1, 2)

julia&gt; AbstractPPL.is_dynamic(vn2)
false</code></pre><p>Alternatively, you can pass <code>true</code> as the second positional argument to the <code>@varname</code> macro (note that it is not a keyword argument!). This will automatically call <a href="#AbstractPPL.concretize"><code>concretize</code></a> for you, using the top-level symbol to look up the value used for concretization.</p><pre><code class="language-julia-repl hljs">julia&gt; x = randn(2, 3);

julia&gt; @varname(x[1:end, end][:], true)
x[1:2, 3][:]</code></pre><p><strong>Interpolation</strong></p><p>Property names, as well as top-level symbols, can also be constructed from interpolated symbols:</p><pre><code class="language-julia-repl hljs">julia&gt; name = :hello; @varname(x.$name)
x.hello

julia&gt; @varname($name)
hello

julia&gt; @varname($name.a.$name[1])
hello.a.hello[1]</code></pre><p>For indices, you do not need to use <code>$</code> to interpolate, just use the variable directly:</p><pre><code class="language-julia-repl hljs">julia&gt; ix = 2; @varname(x[ix])
x[2]</code></pre><p>Note that if the top-level symbol is interpolated, automatic concretization is not possible:</p><pre><code class="language-julia-repl hljs">julia&gt; name = :x; @varname($name[1:end], true)
ERROR: LoadError: cannot automatically concretize VarName with interpolated top-level symbol; call `concretize(vn, val)` manually instead
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L137-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.varname"><a class="docstring-binding" href="#AbstractPPL.varname"><code>AbstractPPL.varname</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varname(expr, concretize::Bool)</code></pre><p>Implementation of the <code>@varname</code> macro. See the documentation for <code>@varname</code> for details. This function is exported to allow other macros (e.g. in DynamicPPL) to reuse the same logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L247-L253">source</a></section></details></article><p>You can obtain the components of a <code>VarName</code> using the <code>getsym</code> and <code>getoptic</code> functions:</p><pre><code class="language-julia hljs">getsym(vn), getoptic(vn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:x, Optic(.a[1]))</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.getsym"><a class="docstring-binding" href="#AbstractPPL.getsym"><code>AbstractPPL.getsym</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getsym(vn::VarName)</code></pre><p>Return the symbol of the Julia variable used to generate <code>vn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; getsym(@varname(x[1][2:3]))
:x

julia&gt; getsym(@varname(y))
:y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L18-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.getoptic"><a class="docstring-binding" href="#AbstractPPL.getoptic"><code>AbstractPPL.getoptic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getoptic(vn::VarName)</code></pre><p>Return the optic of the Julia variable used to generate <code>vn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; getoptic(@varname(x[1][2:3]))
Optic([1][2:3])

julia&gt; getoptic(@varname(y))
Optic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L35-L49">source</a></section></details></article><h2 id="Dynamic-indices"><a class="docs-heading-anchor" href="#Dynamic-indices">Dynamic indices</a><a id="Dynamic-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-indices" title="Permalink"></a></h2><p>VarNames may contain &#39;dynamic&#39; indices, that is, indices whose meaning is not known until they are resolved against a specific value. For example, <code>x[end]</code> refers to the last element of <code>x</code>; but we don&#39;t know what that means until we know what <code>x</code> is.</p><p>Specifically, <code>begin</code> and <code>end</code> symbols in indices are treated as dynamic indices. This is also true for any expression that contains <code>begin</code> or <code>end</code>, such as <code>end-1</code> or <code>1:3:end</code>.</p><p>Dynamic indices are represented using an internal type, <code>AbstractPPL.DynamicIndex</code>.</p><pre><code class="language-julia hljs">vn_dyn = @varname(x[1:2:end])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x[DynamicIndex(1:2:end)]</code></pre><p>You can detect whether a VarName contains dynamic indices using the <code>is_dynamic</code> function:</p><pre><code class="language-julia hljs">is_dynamic(vn_dyn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.is_dynamic"><a class="docstring-binding" href="#AbstractPPL.is_dynamic"><code>AbstractPPL.is_dynamic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_dynamic(vn::VarName)</code></pre><p>Return <code>true</code> if <code>vn</code> contains any dynamic indices (i.e., <code>begin</code>, <code>end</code>, or <code>:</code>). If a <code>VarName</code> has been concretized, this will always return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L91-L96">source</a></section></details></article><p>These dynamic indices can be resolved, or <em>concretized</em>, by passing a specific value to the <code>concretize</code> function:</p><pre><code class="language-julia hljs">x = randn(5)
vn_conc = concretize(vn_dyn, x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x[1:2:5]</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.concretize"><a class="docstring-binding" href="#AbstractPPL.concretize"><code>AbstractPPL.concretize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">concretize(vn::VarName, x)</code></pre><p>Return <code>vn</code> concretized on <code>x</code>, i.e. any information related to the runtime shape of <code>x</code> is evaluated. This will convert any <code>begin</code> and <code>end</code> indices in <code>vn</code> to concrete indices with information about the length of the dimension being indexed into.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L82-L88">source</a></section></details></article><h2 id="Optics"><a class="docs-heading-anchor" href="#Optics">Optics</a><a id="Optics-1"></a><a class="docs-heading-anchor-permalink" href="#Optics" title="Permalink"></a></h2><p>The optics used in AbstractPPL.jl are represented as a linked list. For example, the optic <code>.a[1]</code> is a <code>Property</code> optic that contains an <code>Index</code> optic as its child. That means that the &#39;elements&#39; of the linked list can be read from left-to-right:</p><pre><code class="nohighlight hljs">Property{:a} -&gt; Index{1} -&gt; Iden</code></pre><p>All optic linked lists are terminated with an <code>Iden</code> optic, which represents the identity function.</p><pre><code class="language-julia hljs">optic = getoptic(@varname x.a[1])
dump(optic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Property{:a, Index{Tuple{Int64}, @NamedTuple{}, Iden}}
  child: Index{Tuple{Int64}, @NamedTuple{}, Iden}
    ix: Tuple{Int64}
      1: Int64 1
    kw: @NamedTuple{} NamedTuple()
    child: Iden Optic()</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.AbstractOptic"><a class="docstring-binding" href="#AbstractPPL.AbstractOptic"><code>AbstractPPL.AbstractOptic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractOptic</code></pre><p>An abstract type that represents the non-symbol part of a VarName, i.e., the section of the variable that is of interest. For example, in <code>x.a[1][2]</code>, the <code>AbstractOptic</code> represents the <code>.a[1][2]</code> part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.Property"><a class="docstring-binding" href="#AbstractPPL.Property"><code>AbstractPPL.Property</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Property{sym}(child=Iden())</code></pre><p>A property access optic representing access to property <code>sym</code>. A <code>VarName{:x}</code> with this optic represents access to <code>x.sym</code>. The child optic represents any further indexing or property access after this property access operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L286-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.Index"><a class="docstring-binding" href="#AbstractPPL.Index"><code>AbstractPPL.Index</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Index(ix, kw, child=Iden())</code></pre><p>An indexing optic representing access to indices <code>ix</code>, which may also take the form of keyword arguments <code>kw</code>. A <code>VarName{:x}</code> with this optic represents access to <code>x[ix..., kw...]</code>. The child optic represents any further indexing or property access after this indexing operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L151-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.Iden"><a class="docstring-binding" href="#AbstractPPL.Iden"><code>AbstractPPL.Iden</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Iden()</code></pre><p>The identity optic. This is the optic used when we are referring to the entire variable. It is also the base case for composing optics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L23-L28">source</a></section></details></article><p>Instead of calling <code>getoptic(@varname(...))</code>, you can directly use the <a href="#AbstractPPL.@opticof"><code>@opticof</code></a> macro to create optics:</p><pre><code class="language-julia hljs">optic = @opticof(_.a[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Optic(.a[1])</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.@opticof"><a class="docstring-binding" href="#AbstractPPL.@opticof"><code>AbstractPPL.@opticof</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@opticof(expr, concretize=false)</code></pre><p>Extract the optic from <code>@varname(expr, concretize)</code>. This is a thin wrapper around <code>getoptic(@varname(...))</code>.</p><p>If you don&#39;t need to concretize, you should use <code>_</code> as the top-level symbol to indicate that it is not relevant:</p><pre><code class="language-julia-repl hljs">julia&gt; @opticof(_.a.b)
Optic(.a.b)</code></pre><p>If you need to concretize, then you can provide a real variable name (which is then used to look up the value for concretization):</p><pre><code class="language-julia-repl hljs">julia&gt; x = randn(3, 4); @opticof(x[1:end, end], true)
Optic([1:3, 4])</code></pre><p>Note that concretization with <code>@opticof</code> has the same limitations as with <code>@varname</code>, specifically, if the top-level symbol is interpolated, automatic concretization is not possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L337-L362">source</a></section></details></article><h2 id="Getting-and-setting"><a class="docs-heading-anchor" href="#Getting-and-setting">Getting and setting</a><a id="Getting-and-setting-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-and-setting" title="Permalink"></a></h2><p>Optics are callable structs, and when passed a value will extract the relevant part of that value.</p><pre><code class="language-julia hljs">data = (a=[10, 20, 30], b=&quot;hello&quot;)
optic = @opticof(_.a[2])
optic(data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20</code></pre><p>You can set values using <code>Accessors.set</code> (which AbstractPPL re-exports). Note, though, that this will not mutate the original value. Furthermore, you cannot use the handy macros like <code>Accessors.@set</code>, since those will use the optics from Accessors.jl.</p><pre><code class="language-julia hljs">new_data = set(data, optic, 99)
new_data, data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((a = [10, 99, 30], b = &quot;hello&quot;), (a = [10, 20, 30], b = &quot;hello&quot;))</code></pre><p>If you want to try to mutate values, you can wrap an optic using <code>with_mutation</code>.</p><pre><code class="language-julia hljs">optic_mut = with_mutation(optic)
set(data, optic_mut, 99)
data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(a = [10, 99, 30], b = &quot;hello&quot;)</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.with_mutation"><a class="docstring-binding" href="#AbstractPPL.with_mutation"><code>AbstractPPL.with_mutation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">with_mutation(o::AbstractOptic)</code></pre><p>Create a version of the optic <code>o</code> which attempts to mutate its input where possible.</p><p>On their own, <code>AbstractOptic</code>s are non-mutating:</p><pre><code class="language-julia-repl hljs">julia&gt; optic = @opticof(_[1])
Optic([1])

julia&gt; x = [0.0, 0.0];

julia&gt; set(x, optic, 1.0); x
2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>With this function, we can create a mutating version of the optic:</p><pre><code class="language-julia-repl hljs">julia&gt; optic_mut = with_mutation(@opticof(_[1]))
Optic!!([1])

julia&gt; x = [0.0, 0.0];

julia&gt; set(x, optic_mut, 1.0); x
2-element Vector{Float64}:
 1.0
 0.0</code></pre><p>Thanks to the BangBang.jl package, this optic will gracefully fall back to non-mutating behaviour if mutation is not possible. For example, if we try to use it on a tuple:</p><pre><code class="language-julia-repl hljs">julia&gt; optic_mut = with_mutation(@opticof(_[1]))
Optic!!([1])

julia&gt; x = (0.0, 0.0);

julia&gt; set(x, optic_mut, 1.0); x
(0.0, 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L461-L506">source</a></section></details></article><h2 id="Composing-and-decomposing-optics"><a class="docs-heading-anchor" href="#Composing-and-decomposing-optics">Composing and decomposing optics</a><a id="Composing-and-decomposing-optics-1"></a><a class="docs-heading-anchor-permalink" href="#Composing-and-decomposing-optics" title="Permalink"></a></h2><p>If you have two optics, you can compose them using the <code>∘</code> operator:</p><pre><code class="language-julia hljs">optic1 = @opticof(_.a)
optic2 = @opticof(_[1])
composed = optic2 ∘ optic1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Optic(.a[1])</code></pre><p>Notice the order of composition here, which can be counterintuitive: <code>optic2 ∘ optic1</code> means &quot;first apply <code>optic1</code>, then apply <code>optic2</code>&quot;, and thus this represents the optic <code>.a[1]</code> (not <code>.[1].a</code>).</p><article><details class="docstring" open="true"><summary id="Base.:∘-Tuple{AbstractOptic, AbstractOptic}"><a class="docstring-binding" href="#Base.:∘-Tuple{AbstractOptic, AbstractOptic}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∘(outer::AbstractOptic, inner::AbstractOptic)</code></pre><p>Compose two <code>AbstractOptic</code>s together.</p><pre><code class="language-julia-repl hljs">julia&gt; p1 = @opticof(_.a[1])
Optic(.a[1])

julia&gt; p2 = @opticof(_.b[2, 3])
Optic(.b[2, 3])

julia&gt; p1 ∘ p2
Optic(.b[2, 3].a[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L322-L337">source</a></section></details></article><p><code>Base.cat(optics...)</code> is also provided, which composes optics in a more intuitive sense (indeed, if you think of an optic as a linked list, this can be thought of as concatenating the lists). The following is equivalent to the previous example:</p><pre><code class="language-julia hljs">composed2 = Base.cat(optic1, optic2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Optic(.a[1])</code></pre><article><details class="docstring" open="true"><summary id="Base.cat-Tuple{Vararg{AbstractOptic}}"><a class="docstring-binding" href="#Base.cat-Tuple{Vararg{AbstractOptic}}"><code>Base.cat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cat(optics::AbstractOptic...)</code></pre><p>Compose multiple <code>AbstractOptic</code>s together. The optics should be provided from innermost to outermost, i.e., <code>cat(o1, o2, o3)</code> corresponds to <code>o3 ∘ o2 ∘ o1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L354-L360">source</a></section></details></article><p>Several functions are provided to decompose optics, which all stem from their linked-list structure. Their names directly mirror Haskell&#39;s functions for decomposing lists, but are prefixed with <code>o</code>:</p><article><details class="docstring" open="true"><summary id="AbstractPPL.ohead"><a class="docstring-binding" href="#AbstractPPL.ohead"><code>AbstractPPL.ohead</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ohead(optic::AbstractOptic)</code></pre><p>Get the innermost layer of an optic. For all optics, we have that <code>otail(optic) ∘ ohead(optic) == optic</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ohead(@opticof _.a[1][2])
Optic(.a)

julia&gt; ohead(@opticof _)
Optic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L365-L378">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.otail"><a class="docstring-binding" href="#AbstractPPL.otail"><code>AbstractPPL.otail</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">otail(optic::AbstractOptic)</code></pre><p>Get everything but the innermost layer of an optic. For all optics, we have that <code>otail(optic) ∘ ohead(optic) == optic</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; otail(@opticof _.a[1][2])
Optic([1][2])

julia&gt; otail(@opticof _)
Optic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L383-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.oinit"><a class="docstring-binding" href="#AbstractPPL.oinit"><code>AbstractPPL.oinit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">oinit(optic::AbstractOptic)</code></pre><p>Get everything but the outermost layer of an optic. For all optics, we have that <code>olast(optic) ∘ oinit(optic) == optic</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; oinit(@opticof _.a[1][2])
Optic(.a[1])

julia&gt; oinit(@opticof _)
Optic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L431-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.olast"><a class="docstring-binding" href="#AbstractPPL.olast"><code>AbstractPPL.olast</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">olast(optic::AbstractOptic)</code></pre><p>Get the outermost layer of an optic. For all optics, we have that <code>olast(optic) ∘ oinit(optic) == optic</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; olast(@opticof _.a[1][2])
Optic([2])

julia&gt; olast(@opticof _)
Optic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/optic.jl#L401-L414">source</a></section></details></article><p>For example, <code>ohead</code> returns the first element of the optic linked list, and <code>otail</code> returns the rest of the list after removing the head:</p><pre><code class="language-julia hljs">optic = @opticof(_.a[1].b[2])
ohead(optic), otail(optic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Optic(.a), Optic([1].b[2]))</code></pre><p>Convesely, <code>oinit</code> returns the optic linked list without its last element, and <code>olast</code> returns the last element:</p><pre><code class="language-julia hljs">oinit(optic), olast(optic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Optic(.a[1].b), Optic([2]))</code></pre><p>If the optic only has a single element, then <code>oinit</code> and <code>otail</code> return <code>Iden</code>, while <code>ohead</code> and <code>olast</code> return the optic itself:</p><pre><code class="language-julia hljs">optic_single = @opticof(_.a)
oinit(optic_single), olast(optic_single), ohead(optic_single), otail(optic_single)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Optic(), Optic(.a), Optic(.a), Optic())</code></pre><h2 id="Converting-VarNames-to-optics-and-back"><a class="docs-heading-anchor" href="#Converting-VarNames-to-optics-and-back">Converting VarNames to optics and back</a><a id="Converting-VarNames-to-optics-and-back-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-VarNames-to-optics-and-back" title="Permalink"></a></h2><p>Sometimes it is useful to treat a VarName&#39;s top level symbol as if it were part of the optic. For example, when indexing into a NamedTuple <code>nt</code>, we might want to treat the entire VarName <code>x.a[1]</code> as an optic that can be applied to a NamedTuple: i.e., we want to access the <code>nt.x</code> field rather than the variable <code>x</code> itself. This can be achieved with:</p><article><details class="docstring" open="true"><summary id="AbstractPPL.varname_to_optic"><a class="docstring-binding" href="#AbstractPPL.varname_to_optic"><code>AbstractPPL.varname_to_optic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varname_to_optic(vn::VarName)</code></pre><p>Convert a <code>VarName</code> to an optic, by converting the top-level symbol to a <code>Property</code> optic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L367-L371">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.optic_to_varname"><a class="docstring-binding" href="#AbstractPPL.optic_to_varname"><code>AbstractPPL.optic_to_varname</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optic_to_varname(optic::Property{sym}) where {sym}</code></pre><p>Convert a <code>Property</code> optic to a <code>VarName</code>, by converting the top-level property to a symbol. This fails for all other optics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/varname.jl#L374-L379">source</a></section></details></article><h2 id="Subsumption"><a class="docs-heading-anchor" href="#Subsumption">Subsumption</a><a id="Subsumption-1"></a><a class="docs-heading-anchor-permalink" href="#Subsumption" title="Permalink"></a></h2><p>Sometimes, we want to check whether one VarName &#39;subsumes&#39; another; that is, whether a VarName refers to a part of another VarName. This is done using the <a href="#AbstractPPL.subsumes"><code>subsumes</code></a> function:</p><pre><code class="language-julia hljs">vn1 = @varname(x.a)
vn2 = @varname(x.a[1])
subsumes(vn1, vn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><article><details class="docstring" open="true"><summary id="AbstractPPL.subsumes"><a class="docstring-binding" href="#AbstractPPL.subsumes"><code>AbstractPPL.subsumes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subsumes(parent::VarName, child::VarName)</code></pre><p>Check whether the variable name <code>child</code> describes a sub-range of the variable <code>parent</code>, i.e., is contained within it.</p><pre><code class="language-julia-repl hljs">julia&gt; subsumes(@varname(x), @varname(x[1, 2]))
true

julia&gt; subsumes(@varname(x[1, 2]), @varname(x[1, 2][3]))
true</code></pre><p>This is done by recursively comparing each layer of the VarNames&#39; optics.</p><p>Note that often this is not possible to determine statically, and so the results should not be over-interpreted. In particular, <code>Index</code> optics  pose a problem. An <code>i::Index</code> will only subsume <code>j::Index</code> if:</p><ol><li>They have the same number of positional indices (<code>i.ix</code> and <code>j.ix</code>);</li><li>Each positional index in <code>i</code> can be determined to comprise the corresponding positional index in <code>j</code>; and</li><li>The keyword indices of <code>i</code> (<code>i.kw</code>) are a superset of those in <code>j.kw</code>).</li></ol><p>In all other cases, <code>subsumes</code> will conservatively return <code>false</code>, even though in practice it might well be that <code>i</code> does subsume <code>j</code>. Some examples where subsumption cannot be determined statically are:</p><ul><li>Subsumption between different forms of indexing is not supported, e.g. <code>x[4]</code> and <code>x[2, 2]</code> are not considered to subsume each other, even though they might in practice (e.g. if <code>x</code> is a 2x2 matrix).</li><li>When dynamic indices (that are not equal) are present. (Dynamic indices that are equal do subsume each other.)</li><li>Non-standard indices, e.g. <code>Not(4)</code>, <code>2..3</code>, etc. Again, these only subsume each other when they are equal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/subsumes.jl#L1-L37">source</a></section></details></article><h2 id="Prefixing-and-unprefixing"><a class="docs-heading-anchor" href="#Prefixing-and-unprefixing">Prefixing and unprefixing</a><a id="Prefixing-and-unprefixing-1"></a><a class="docs-heading-anchor-permalink" href="#Prefixing-and-unprefixing" title="Permalink"></a></h2><p>Composing two optics can be done using the <code>∘</code> operator, as shown above. But what if we want to compose two <code>VarName</code>s? This is used, for example, in DynamicPPL&#39;s submodel functionality.</p><article><details class="docstring" open="true"><summary id="AbstractPPL.prefix"><a class="docstring-binding" href="#AbstractPPL.prefix"><code>AbstractPPL.prefix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prefix(vn::VarName, prefix::VarName)</code></pre><p>Add a prefix to a VarName.</p><pre><code class="language-julia-repl hljs">julia&gt; prefix(@varname(x), @varname(y))
y.x

julia&gt; prefix(@varname(x.a), @varname(y))
y.x.a

julia&gt; prefix(@varname(x.a), @varname(y[1]))
y[1].x.a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/prefix.jl#L48-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.unprefix"><a class="docstring-binding" href="#AbstractPPL.unprefix"><code>AbstractPPL.unprefix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unprefix(vn::VarName, prefix::VarName)</code></pre><p>Remove a prefix from a VarName.</p><pre><code class="language-julia-repl hljs">julia&gt; unprefix(@varname(y.x), @varname(y))
x

julia&gt; unprefix(@varname(y.x.a), @varname(y))
x.a

julia&gt; unprefix(@varname(y[1].x), @varname(y[1]))
x

julia&gt; unprefix(@varname(y), @varname(n))
ERROR: ArgumentError: cannot remove prefix n from VarName y
[...]

julia&gt; unprefix(@varname(y[1]), @varname(y))
ERROR: ArgumentError: optic_to_varname: can only convert Property optics to VarName
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/prefix.jl#L12-L35">source</a></section></details></article><h2 id="VarName-leaves"><a class="docs-heading-anchor" href="#VarName-leaves">VarName leaves</a><a id="VarName-leaves-1"></a><a class="docs-heading-anchor-permalink" href="#VarName-leaves" title="Permalink"></a></h2><p>The following functions are used to extract the &#39;leaves&#39; of a VarName, that is, the atomic components of a VarName that do not have any further substructure. For example, for a vector variable <code>x</code>, the leaves would be <code>x[1]</code>, <code>x[2]</code>, etc.</p><article><details class="docstring" open="true"><summary id="AbstractPPL.varname_leaves"><a class="docstring-binding" href="#AbstractPPL.varname_leaves"><code>AbstractPPL.varname_leaves</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varname_leaves(vn::VarName, val)</code></pre><p>Return an iterator over all varnames that are represented by <code>vn</code> on <code>val</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using AbstractPPL: varname_leaves

julia&gt; foreach(println, varname_leaves(@varname(x), rand(2)))
x[1]
x[2]

julia&gt; foreach(println, varname_leaves(@varname(x[1:2]), rand(2)))
x[1:2][1]
x[1:2][2]

julia&gt; x = (y = 1, z = [[2.0], [3.0]]);

julia&gt; foreach(println, varname_leaves(@varname(x), x))
x.y
x.z[1][1]
x.z[2][1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/leaves.jl#L2-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.varname_and_value_leaves"><a class="docstring-binding" href="#AbstractPPL.varname_and_value_leaves"><code>AbstractPPL.varname_and_value_leaves</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varname_and_value_leaves(vn::VarName, val)</code></pre><p>Return an iterator over all varname-value pairs that are represented by <code>vn</code> on <code>val</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using AbstractPPL: varname_and_value_leaves

julia&gt; foreach(println, varname_and_value_leaves(@varname(x), 1:2))
(x[1], 1)
(x[2], 2)

julia&gt; foreach(println, varname_and_value_leaves(@varname(x[1:2]), 1:2))
(x[1:2][1], 1)
(x[1:2][2], 2)

julia&gt; x = (y = 1, z = [[2.0], [3.0]]);

julia&gt; foreach(println, varname_and_value_leaves(@varname(x), x))
(x.y, 1)
(x.z[1][1], 2.0)
(x.z[2][1], 3.0)</code></pre><p>There is also some special handling for certain types:</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; x = reshape(1:4, 2, 2);

julia&gt; # `LowerTriangular`
       foreach(println, varname_and_value_leaves(@varname(x), LowerTriangular(x)))
(x[1, 1], 1)
(x[2, 1], 2)
(x[2, 2], 4)

julia&gt; # `UpperTriangular`
       foreach(println, varname_and_value_leaves(@varname(x), UpperTriangular(x)))
(x[1, 1], 1)
(x[1, 2], 3)
(x[2, 2], 4)

julia&gt; # `Cholesky` with lower-triangular
       foreach(println, varname_and_value_leaves(@varname(x), Cholesky([1.0 0.0; 0.0 1.0], &#39;L&#39;, 0)))
(x.L[1, 1], 1.0)
(x.L[2, 1], 0.0)
(x.L[2, 2], 1.0)

julia&gt; # `Cholesky` with upper-triangular
       foreach(println, varname_and_value_leaves(@varname(x), Cholesky([1.0 0.0; 0.0 1.0], &#39;U&#39;, 0)))
(x.U[1, 1], 1.0)
(x.U[1, 2], 0.0)
(x.U[2, 2], 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/leaves.jl#L70-L126">source</a></section><section><div><pre><code class="language-julia hljs">varname_and_value_leaves(container)</code></pre><p>Return an iterator over all varname-value pairs that are represented by <code>container</code>.</p><p>This is the same as <a href="#AbstractPPL.varname_and_value_leaves"><code>varname_and_value_leaves(vn::VarName, x)</code></a> but over a container containing multiple varnames.</p><p>See also: <a href="#AbstractPPL.varname_and_value_leaves"><code>varname_and_value_leaves(vn::VarName, x)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using AbstractPPL: varname_and_value_leaves

julia&gt; using OrderedCollections: OrderedDict

julia&gt; # With an `AbstractDict` (we use `OrderedDict` here
       # to ensure consistent ordering in doctests)
       dict = OrderedDict(@varname(y) =&gt; 1, @varname(z) =&gt; [[2.0], [3.0]]);

julia&gt; foreach(println, varname_and_value_leaves(dict))
(y, 1)
(z[1][1], 2.0)
(z[2][1], 3.0)

julia&gt; # With a `NamedTuple`
       nt = (y = 1, z = [[2.0], [3.0]]);

julia&gt; foreach(println, varname_and_value_leaves(nt))
(y, 1)
(z[1][1], 2.0)
(z[2][1], 3.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/leaves.jl#L131-L164">source</a></section></details></article><h2 id="Reading-from-a-container-with-a-VarName-(or-optic)"><a class="docs-heading-anchor" href="#Reading-from-a-container-with-a-VarName-(or-optic)">Reading from a container with a VarName (or optic)</a><a id="Reading-from-a-container-with-a-VarName-(or-optic)-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-from-a-container-with-a-VarName-(or-optic)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="AbstractPPL.canview"><a class="docstring-binding" href="#AbstractPPL.canview"><code>AbstractPPL.canview</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">canview(optic, container)</code></pre><p>Return <code>true</code> if <code>optic</code> can be used to view <code>container</code>, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AbstractPPL.canview(@opticof(_.a), (a = 1.0, ))
true

julia&gt; AbstractPPL.canview(@opticof(_.a), (b = 1.0, )) # property `a` does not exist
false

julia&gt; AbstractPPL.canview(@opticof(_.a[1]), (a = [1.0, 2.0], ))
true

julia&gt; AbstractPPL.canview(@opticof(_.a[3]), (a = [1.0, 2.0], )) # out of bounds
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/hasvalue.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.hasvalue"><a class="docstring-binding" href="#AbstractPPL.hasvalue"><code>AbstractPPL.hasvalue</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hasvalue(
    vals::Union{AbstractDict,NamedTuple},
    vn::VarName,
    dist::Distribution;
    error_on_incomplete::Bool=false
)</code></pre><p>Check if <code>vals</code> contains values for <code>vn</code> that is compatible with the distribution <code>dist</code>.</p><p>This is a more general version of <code>hasvalue(vals, vn)</code>, in that even if <code>vn</code> itself is not inside <code>vals</code>, it further checks if <code>vals</code> contains sub-values of <code>vn</code> that can be used to reconstruct <code>vn</code> given <code>dist</code>.</p><p>The <code>error_on_incomplete</code> flag can be used to detect cases where <em>some</em> of the values needed for <code>vn</code> are present, but others are not. This may help to detect invalid cases where the user has provided e.g. data of the wrong shape.</p><p>Note that this check is only possible if a Dict is passed, because the key type of a NamedTuple (i.e., Symbol) is not rich enough to carry indexing information. If this method is called with a NamedTuple, it will just defer to <code>hasvalue(vals, vn)</code>.</p><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(@varname(x[1]) =&gt; 1.0, @varname(x[2]) =&gt; 2.0);

julia&gt; hasvalue(d, @varname(x), MvNormal(zeros(2), I))
true

julia&gt; hasvalue(d, @varname(x), MvNormal(zeros(3), I))
false

julia&gt; hasvalue(d, @varname(x), MvNormal(zeros(3), I); error_on_incomplete=true)
ERROR: only partial values for `x` found in the dictionary provided
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/ext/AbstractPPLDistributionsExt.jl#L110-L150">source</a></section><section><div><pre><code class="language-julia hljs">hasvalue(vals::NamedTuple, vn::VarName)
hasvalue(vals::AbstractDict{&lt;:VarName}, vn::VarName)</code></pre><p>Determine whether <code>vals</code> contains a value for a given <code>vn</code>.</p><p><strong>Examples</strong></p><p>With <code>x</code> as a <code>NamedTuple</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; hasvalue((x = 1.0, ), @varname(x))
true

julia&gt; hasvalue((x = 1.0, ), @varname(x[1]))
false

julia&gt; hasvalue((x = [1.0],), @varname(x))
true

julia&gt; hasvalue((x = [1.0],), @varname(x[1]))
true

julia&gt; hasvalue((x = [1.0],), @varname(x[2]))
false</code></pre><p>With <code>x</code> as a <code>AbstractDict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; hasvalue(Dict(@varname(x) =&gt; 1.0, ), @varname(x))
true

julia&gt; hasvalue(Dict(@varname(x) =&gt; 1.0, ), @varname(x[1]))
false

julia&gt; hasvalue(Dict(@varname(x) =&gt; [1.0]), @varname(x))
true

julia&gt; hasvalue(Dict(@varname(x) =&gt; [1.0]), @varname(x[1]))
true

julia&gt; hasvalue(Dict(@varname(x) =&gt; [1.0]), @varname(x[2]))
false</code></pre><p>In the <code>AbstractDict</code> case we can also have keys such as <code>v[1]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; vals = Dict(@varname(x[1]) =&gt; [1.0,]);

julia&gt; hasvalue(vals, @varname(x[1])) # same as `haskey`
true

julia&gt; hasvalue(vals, @varname(x[1][1])) # different from `haskey`
true

julia&gt; hasvalue(vals, @varname(x[1][2]))
false

julia&gt; hasvalue(vals, @varname(x[2][1]))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/hasvalue.jl#L195-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.getvalue"><a class="docstring-binding" href="#AbstractPPL.getvalue"><code>AbstractPPL.getvalue</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getvalue(
    vals::Union{AbstractDict,NamedTuple},
    vn::VarName,
    dist::Distribution
)</code></pre><p>Retrieve the value of <code>vn</code> from <code>vals</code>, using the distribution <code>dist</code> to reconstruct the value if necessary.</p><p>This is a more general version of <code>getvalue(vals, vn)</code>, in that even if <code>vn</code> itself is not inside <code>vals</code>, it can still reconstruct the value of <code>vn</code> from sub-values of <code>vn</code> that are present in <code>vals</code>.</p><p>Note that this reconstruction is only possible if a Dict is passed, because the key type of a NamedTuple (i.e., Symbol) is not rich enough to carry indexing information. If this method is called with a NamedTuple, it will just defer to <code>getvalue(vals, vn)</code>.</p><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(@varname(x[1]) =&gt; 1.0, @varname(x[2]) =&gt; 2.0);

julia&gt; getvalue(d, @varname(x), MvNormal(zeros(2), I))
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; # Use `hasvalue` to check for this case before calling `getvalue`.
       getvalue(d, @varname(x), MvNormal(zeros(3), I))
ERROR: `x` was not found in the dictionary provided
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/ext/AbstractPPLDistributionsExt.jl#L215-L249">source</a></section><section><div><pre><code class="language-julia hljs">getvalue(vals::NamedTuple, vn::VarName)
getvalue(vals::AbstractDict{&lt;:VarName}, vn::VarName)</code></pre><p>Return the value(s) in <code>vals</code> represented by <code>vn</code>.</p><p><strong>Examples</strong></p><p>For <code>NamedTuple</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; vals = (x = [1.0],);

julia&gt; getvalue(vals, @varname(x)) # same as `getindex`
1-element Vector{Float64}:
 1.0

julia&gt; getvalue(vals, @varname(x[1])) # different from `getindex`
1.0

julia&gt; getvalue(vals, @varname(x[2]))
ERROR: x[2] was not found in the NamedTuple provided
[...]</code></pre><p>For <code>AbstractDict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; vals = Dict(@varname(x) =&gt; [1.0]);

julia&gt; getvalue(vals, @varname(x)) # same as `getindex`
1-element Vector{Float64}:
 1.0

julia&gt; getvalue(vals, @varname(x[1])) # different from `getindex`
1.0

julia&gt; getvalue(vals, @varname(x[2]))
ERROR: x[2] was not found in the dictionary provided
[...]</code></pre><p>In the <code>AbstractDict</code> case we can also have keys such as <code>v[1]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; vals = Dict(@varname(x[1]) =&gt; [1.0,]);

julia&gt; getvalue(vals, @varname(x[1])) # same as `getindex`
1-element Vector{Float64}:
 1.0

julia&gt; getvalue(vals, @varname(x[1][1])) # different from `getindex`
1.0

julia&gt; getvalue(vals, @varname(x[1][2]))
ERROR: x[1][2] was not found in the dictionary provided
[...]

julia&gt; getvalue(vals, @varname(x[2][1]))
ERROR: x[2][1] was not found in the dictionary provided
[...]

julia&gt; getvalue(vals, @varname(x))
ERROR: x was not found in the dictionary provided
[...]</code></pre><p>Dictionaries can present ambiguous cases where the same variable is specified twice at different levels. In such a situation, <code>getvalue</code> attempts to find an exact match, and if that fails it returns the value with the most specific key.</p><div class="admonition is-info" id="Note-17d0ec06f88bd90f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-17d0ec06f88bd90f" title="Permalink"></a></header><div class="admonition-body"><p>It is the user&#39;s responsibility to avoid such cases by ensuring that the dictionary passed in does not contain the same value specified multiple times.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; vals = Dict(@varname(x) =&gt; [[1.0]], @varname(x[1]) =&gt; [2.0]);

julia&gt; # Here, the `x[1]` key is not used because `x` is an exact match.
       getvalue(vals, @varname(x))
1-element Vector{Vector{Float64}}:
 [1.0]

julia&gt; # Likewise, the `x` key is not used because `x[1]` is an exact match.
       getvalue(vals, @varname(x[1]))
1-element Vector{Float64}:
 2.0

julia&gt; # No exact match, so the most specific key, i.e. `x[1]`, is used.
       getvalue(vals, @varname(x[1][1]))
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/hasvalue.jl#L59-L152">source</a></section></details></article><h2 id="Serializing-VarNames"><a class="docs-heading-anchor" href="#Serializing-VarNames">Serializing VarNames</a><a id="Serializing-VarNames-1"></a><a class="docs-heading-anchor-permalink" href="#Serializing-VarNames" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="AbstractPPL.index_to_dict"><a class="docstring-binding" href="#AbstractPPL.index_to_dict"><code>AbstractPPL.index_to_dict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">index_to_dict(::Integer)
index_to_dict(::AbstractVector{Int})
index_to_dict(::UnitRange)
index_to_dict(::StepRange)
index_to_dict(::Colon)
index_to_dict(::ConcretizedSlice{T, Base.OneTo{I}}) where {T, I}
index_to_dict(::Tuple)</code></pre><p>Convert an index <code>i</code> to a dictionary representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/serialize.jl#L15-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.dict_to_index"><a class="docstring-binding" href="#AbstractPPL.dict_to_index"><code>AbstractPPL.dict_to_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dict_to_index(dict)
dict_to_index(symbol_val, dict)</code></pre><p>Convert a dictionary representation of an index <code>dict</code> to an index.</p><p>Users can extend the functionality of <code>dict_to_index</code> (and hence <code>VarName</code> de/serialisation) by extending this method along with <a href="#AbstractPPL.index_to_dict"><code>index_to_dict</code></a>. Specifically, suppose you have a custom index type <code>MyIndexType</code> and you want to be able to de/serialise a <code>VarName</code> containing this index type. You should then implement the following two methods:</p><ol><li><p><code>AbstractPPL.index_to_dict(i::MyModule.MyIndexType)</code> should return a dictionary representation of the index <code>i</code>. This dictionary must contain the key <code>&quot;type&quot;</code>, and the corresponding value must be a string that uniquely identifies the index type. Generally, it makes sense to use the name of the type (perhaps prefixed with module qualifiers) as this value to avoid clashes. The remainder of the dictionary can have any structure you like.</p></li><li><p>Suppose the value of <code>index_to_dict(i)[&quot;type&quot;]</code> is <code>&quot;MyModule.MyIndexType&quot;</code>. You should then implement the corresponding method <code>AbstractPPL.dict_to_index(::Val{Symbol(&quot;MyModule.MyIndexType&quot;)}, dict)</code>, which should take the dictionary representation as the second argument and return the original <code>MyIndexType</code> object.</p></li></ol><p>To see an example of this in action, you can look in the the AbstractPPL test suite, which contains a test for serialising OffsetArrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/serialize.jl#L54-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.varname_to_string"><a class="docstring-binding" href="#AbstractPPL.varname_to_string"><code>AbstractPPL.varname_to_string</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varname_to_string(vn::VarName)</code></pre><p>Convert a <code>VarName</code> as a string, via an intermediate dictionary. This differs from <code>string(vn)</code> in that concretised slices are faithfully represented (rather than being pretty-printed as colons).</p><p>For <code>VarName</code>s which index into an array, this function will only work if the indices can be serialised. This is true for all standard Julia index types, but if you are using custom index types, you will need to implement the <code>index_to_dict</code> and <code>dict_to_index</code> methods for those types. See the documentation of <a href="#AbstractPPL.dict_to_index"><code>dict_to_index</code></a> for instructions on how to do this.</p><pre><code class="language-julia-repl hljs">julia&gt; varname_to_string(@varname(x))
&quot;{\&quot;optic\&quot;:{\&quot;type\&quot;:\&quot;Iden\&quot;},\&quot;sym\&quot;:\&quot;x\&quot;}&quot;

julia&gt; varname_to_string(@varname(x.a))
&quot;{\&quot;optic\&quot;:{\&quot;child\&quot;:{\&quot;type\&quot;:\&quot;Iden\&quot;},\&quot;field\&quot;:\&quot;a\&quot;,\&quot;type\&quot;:\&quot;Property\&quot;},\&quot;sym\&quot;:\&quot;x\&quot;}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/serialize.jl#L151-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.string_to_varname"><a class="docstring-binding" href="#AbstractPPL.string_to_varname"><code>AbstractPPL.string_to_varname</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">string_to_varname(str::AbstractString)</code></pre><p>Convert a string representation of a <code>VarName</code> back to a <code>VarName</code>. The string should have been generated by <code>varname_to_string</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractPPL.jl/blob/d4ffbdb03c9281198ff707d8a29ae735f1462593/src/varname/serialize.jl#L174-L179">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« AbstractPPL.jl</a><a class="docs-footer-nextpage" href="../pplapi/">Probabilistic programming API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 24 December 2025 21:44">Wednesday 24 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
